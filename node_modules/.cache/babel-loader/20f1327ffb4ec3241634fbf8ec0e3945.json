{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst urlLib = require('url');\n\nconst querystring = require('querystring');\n\nconst duplexer3 = require('duplexer3');\n\nconst isStream = require('is-stream');\n\nconst getStream = require('get-stream');\n\nconst timedOut = require('timed-out');\n\nconst urlParseLax = require('url-parse-lax');\n\nconst lowercaseKeys = require('lowercase-keys');\n\nconst isRedirect = require('is-redirect');\n\nconst unzipResponse = require('unzip-response');\n\nconst createErrorClass = require('create-error-class');\n\nconst isRetryAllowed = require('is-retry-allowed');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst pkg = require('./package');\n\nfunction requestAsEventEmitter(opts) {\n  opts = opts || {};\n  const ee = new EventEmitter();\n  const requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);\n  let redirectCount = 0;\n  let retryCount = 0;\n  let redirectUrl;\n\n  const get = opts => {\n    const fn = opts.protocol === 'https:' ? https : http;\n    const req = fn.request(opts, res => {\n      const statusCode = res.statusCode;\n\n      if (isRedirect(statusCode) && opts.followRedirect && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) {\n        res.resume();\n\n        if (++redirectCount > 10) {\n          ee.emit('error', new got.MaxRedirectsError(statusCode, opts), null, res);\n          return;\n        }\n\n        const bufferString = Buffer.from(res.headers.location, 'binary').toString();\n        redirectUrl = urlLib.resolve(urlLib.format(opts), bufferString);\n        const redirectOpts = Object.assign({}, opts, urlLib.parse(redirectUrl));\n        ee.emit('redirect', res, redirectOpts);\n        get(redirectOpts);\n        return;\n      }\n\n      setImmediate(() => {\n        const response = typeof unzipResponse === 'function' && req.method !== 'HEAD' ? unzipResponse(res) : res;\n        response.url = redirectUrl || requestUrl;\n        response.requestUrl = requestUrl;\n        ee.emit('response', response);\n      });\n    });\n    req.once('error', err => {\n      const backoff = opts.retries(++retryCount, err);\n\n      if (backoff) {\n        setTimeout(get, backoff, opts);\n        return;\n      }\n\n      ee.emit('error', new got.RequestError(err, opts));\n    });\n\n    if (opts.gotTimeout) {\n      timedOut(req, opts.gotTimeout);\n    }\n\n    setImmediate(() => {\n      ee.emit('request', req);\n    });\n  };\n\n  get(opts);\n  return ee;\n}\n\nfunction asPromise(opts) {\n  return new Promise((resolve, reject) => {\n    const ee = requestAsEventEmitter(opts);\n    ee.on('request', req => {\n      if (isStream(opts.body)) {\n        opts.body.pipe(req);\n        opts.body = undefined;\n        return;\n      }\n\n      req.end(opts.body);\n    });\n    ee.on('response', res => {\n      const stream = opts.encoding === null ? getStream.buffer(res) : getStream(res, opts);\n      stream.catch(err => reject(new got.ReadError(err, opts))).then(data => {\n        const statusCode = res.statusCode;\n        const limitStatusCode = opts.followRedirect ? 299 : 399;\n        res.body = data;\n\n        if (opts.json && res.body) {\n          try {\n            res.body = JSON.parse(res.body);\n          } catch (e) {\n            throw new got.ParseError(e, statusCode, opts, data);\n          }\n        }\n\n        if (statusCode < 200 || statusCode > limitStatusCode) {\n          throw new got.HTTPError(statusCode, opts);\n        }\n\n        resolve(res);\n      }).catch(err => {\n        Object.defineProperty(err, 'response', {\n          value: res\n        });\n        reject(err);\n      });\n    });\n    ee.on('error', reject);\n  });\n}\n\nfunction asStream(opts) {\n  const input = new PassThrough();\n  const output = new PassThrough();\n  const proxy = duplexer3(input, output);\n\n  if (opts.json) {\n    throw new Error('got can not be used as stream when options.json is used');\n  }\n\n  if (opts.body) {\n    proxy.write = () => {\n      throw new Error('got\\'s stream is not writable when options.body is used');\n    };\n  }\n\n  const ee = requestAsEventEmitter(opts);\n  ee.on('request', req => {\n    proxy.emit('request', req);\n\n    if (isStream(opts.body)) {\n      opts.body.pipe(req);\n      return;\n    }\n\n    if (opts.body) {\n      req.end(opts.body);\n      return;\n    }\n\n    if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n      input.pipe(req);\n      return;\n    }\n\n    req.end();\n  });\n  ee.on('response', res => {\n    const statusCode = res.statusCode;\n    res.pipe(output);\n\n    if (statusCode < 200 || statusCode > 299) {\n      proxy.emit('error', new got.HTTPError(statusCode, opts), null, res);\n      return;\n    }\n\n    proxy.emit('response', res);\n  });\n  ee.on('redirect', proxy.emit.bind(proxy, 'redirect'));\n  ee.on('error', proxy.emit.bind(proxy, 'error'));\n  return proxy;\n}\n\nfunction normalizeArguments(url, opts) {\n  if (typeof url !== 'string' && typeof url !== 'object') {\n    throw new Error(\"Parameter `url` must be a string or object, not \".concat(typeof url));\n  }\n\n  if (typeof url === 'string') {\n    url = url.replace(/^unix:/, 'http://$&');\n    url = urlParseLax(url);\n\n    if (url.auth) {\n      throw new Error('Basic authentication must be done with auth option');\n    }\n  }\n\n  opts = Object.assign({\n    protocol: 'http:',\n    path: '',\n    retries: 5\n  }, url, opts);\n  opts.headers = Object.assign({\n    'user-agent': \"\".concat(pkg.name, \"/\").concat(pkg.version, \" (https://github.com/sindresorhus/got)\"),\n    'accept-encoding': 'gzip,deflate'\n  }, lowercaseKeys(opts.headers));\n  const query = opts.query;\n\n  if (query) {\n    if (typeof query !== 'string') {\n      opts.query = querystring.stringify(query);\n    }\n\n    opts.path = \"\".concat(opts.path.split('?')[0], \"?\").concat(opts.query);\n    delete opts.query;\n  }\n\n  if (opts.json && opts.headers.accept === undefined) {\n    opts.headers.accept = 'application/json';\n  }\n\n  let body = opts.body;\n\n  if (body) {\n    if (typeof body !== 'string' && !(body !== null && typeof body === 'object')) {\n      throw new Error('options.body must be a ReadableStream, string, Buffer or plain Object');\n    }\n\n    opts.method = opts.method || 'POST';\n\n    if (isStream(body) && typeof body.getBoundary === 'function') {\n      // Special case for https://github.com/form-data/form-data\n      opts.headers['content-type'] = opts.headers['content-type'] || \"multipart/form-data; boundary=\".concat(body.getBoundary());\n    } else if (body !== null && typeof body === 'object' && !Buffer.isBuffer(body) && !isStream(body)) {\n      opts.headers['content-type'] = opts.headers['content-type'] || 'application/x-www-form-urlencoded';\n      body = opts.body = querystring.stringify(body);\n    }\n\n    if (opts.headers['content-length'] === undefined && opts.headers['transfer-encoding'] === undefined && !isStream(body)) {\n      const length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;\n      opts.headers['content-length'] = length;\n    }\n  }\n\n  opts.method = (opts.method || 'GET').toUpperCase();\n\n  if (opts.hostname === 'unix') {\n    const matches = /(.+):(.+)/.exec(opts.path);\n\n    if (matches) {\n      opts.socketPath = matches[1];\n      opts.path = matches[2];\n      opts.host = null;\n    }\n  }\n\n  if (typeof opts.retries !== 'function') {\n    const retries = opts.retries;\n\n    opts.retries = (iter, err) => {\n      if (iter > retries || !isRetryAllowed(err)) {\n        return 0;\n      }\n\n      const noise = Math.random() * 100;\n      return (1 << iter) * 1000 + noise;\n    };\n  }\n\n  if (opts.followRedirect === undefined) {\n    opts.followRedirect = true;\n  }\n\n  if (opts.timeout) {\n    opts.gotTimeout = opts.timeout;\n    delete opts.timeout;\n  }\n\n  return opts;\n}\n\nfunction got(url, opts) {\n  try {\n    return asPromise(normalizeArguments(url, opts));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nconst helpers = ['get', 'post', 'put', 'patch', 'head', 'delete'];\nhelpers.forEach(el => {\n  got[el] = (url, opts) => got(url, Object.assign({}, opts, {\n    method: el\n  }));\n});\n\ngot.stream = (url, opts) => asStream(normalizeArguments(url, opts));\n\nfor (const el of helpers) {\n  got.stream[el] = (url, opts) => got.stream(url, Object.assign({}, opts, {\n    method: el\n  }));\n}\n\nfunction stdError(error, opts) {\n  if (error.code !== undefined) {\n    this.code = error.code;\n  }\n\n  Object.assign(this, {\n    message: error.message,\n    host: opts.host,\n    hostname: opts.hostname,\n    method: opts.method,\n    path: opts.path\n  });\n}\n\ngot.RequestError = createErrorClass('RequestError', stdError);\ngot.ReadError = createErrorClass('ReadError', stdError);\ngot.ParseError = createErrorClass('ParseError', function (e, statusCode, opts, data) {\n  stdError.call(this, e, opts);\n  this.statusCode = statusCode;\n  this.statusMessage = http.STATUS_CODES[this.statusCode];\n  this.message = \"\".concat(e.message, \" in \\\"\").concat(urlLib.format(opts), \"\\\": \\n\").concat(data.slice(0, 77), \"...\");\n});\ngot.HTTPError = createErrorClass('HTTPError', function (statusCode, opts) {\n  stdError.call(this, {}, opts);\n  this.statusCode = statusCode;\n  this.statusMessage = http.STATUS_CODES[this.statusCode];\n  this.message = \"Response code \".concat(this.statusCode, \" (\").concat(this.statusMessage, \")\");\n});\ngot.MaxRedirectsError = createErrorClass('MaxRedirectsError', function (statusCode, opts) {\n  stdError.call(this, {}, opts);\n  this.statusCode = statusCode;\n  this.statusMessage = http.STATUS_CODES[this.statusCode];\n  this.message = 'Redirected 10 times. Aborting.';\n});\nmodule.exports = got;","map":null,"metadata":{},"sourceType":"script"}