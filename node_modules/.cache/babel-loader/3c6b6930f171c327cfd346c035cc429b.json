{"ast":null,"code":"'use strict';\n\nconst bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n  if (!inputStream) {\n    return Promise.reject(new Error('Expected a stream'));\n  }\n\n  opts = Object.assign({\n    maxBuffer: Infinity\n  }, opts);\n  const maxBuffer = opts.maxBuffer;\n  let stream;\n  let clean;\n  const p = new Promise((resolve, reject) => {\n    const error = err => {\n      if (err) {\n        // null check\n        err.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(err);\n    };\n\n    stream = bufferStream(opts);\n    inputStream.once('error', error);\n    inputStream.pipe(stream);\n    stream.on('data', () => {\n      if (stream.getBufferedLength() > maxBuffer) {\n        reject(new Error('maxBuffer exceeded'));\n      }\n    });\n    stream.once('error', error);\n    stream.on('end', resolve);\n\n    clean = () => {\n      // some streams doesn't implement the `stream.Readable` interface correctly\n      if (inputStream.unpipe) {\n        inputStream.unpipe(stream);\n      }\n    };\n  });\n  p.then(clean, clean);\n  return p.then(() => stream.getBufferedValue());\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, {\n  encoding: 'buffer'\n}));\n\nmodule.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, {\n  array: true\n}));","map":null,"metadata":{},"sourceType":"script"}