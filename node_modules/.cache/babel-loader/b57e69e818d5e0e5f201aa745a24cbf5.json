{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\n\nvar fs = require('graceful-fs');\n\nvar chain = require('slide').chain;\n\nvar MurmurHash3 = require('imurmurhash');\n\nvar extend = Object.assign || require('util')._extend;\n\nvar invocations = 0;\n\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(++invocations)).result();\n}\n\nfunction writeFile(filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (!options) options = {};\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback);\n  });\n}\n\nfunction _writeFile(filename, data, options, callback) {\n  var tmpfile = getTmpname(filename);\n\n  if (options.mode && options.chown) {\n    return thenWriteFile();\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile();\n      options = extend({}, options);\n\n      if (!options.mode) {\n        options.mode = stats.mode;\n      }\n\n      if (!options.chown && process.getuid) {\n        options.chown = {\n          uid: stats.uid,\n          gid: stats.gid\n        };\n      }\n\n      return thenWriteFile();\n    });\n  }\n\n  function thenWriteFile() {\n    chain([[writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'], options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid], options.mode && [fs, fs.chmod, tmpfile, options.mode], [fs, fs.rename, tmpfile, filename]], function (err) {\n      err ? fs.unlink(tmpfile, function () {\n        callback(err);\n      }) : callback();\n    });\n  } // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n\n\n  function writeFileAsync(file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err);\n\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose);\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose);\n      } else {\n        return syncAndClose();\n      }\n\n      function syncAndClose(err) {\n        if (err) return cb(err);\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err);\n          fs.close(fd, cb);\n        });\n      }\n    });\n  }\n}\n\nfunction writeFileSync(filename, data, options) {\n  if (!options) options = {};\n\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {// it's ok, it'll happen on a not yet existing file\n  }\n\n  var tmpfile = getTmpname(filename);\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename);\n        options = extend({}, options);\n\n        if (!options.mode) {\n          options.mode = stats.mode;\n        }\n\n        if (!options.chown && process.getuid) {\n          options.chown = {\n            uid: stats.uid,\n            gid: stats.gid\n          };\n        }\n      } catch (ex) {// ignore stat errors\n      }\n    }\n\n    var fd = fs.openSync(tmpfile, 'w', options.mode);\n\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n\n    fs.fsyncSync(fd);\n    fs.closeSync(fd);\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n    if (options.mode) fs.chmodSync(tmpfile, options.mode);\n    fs.renameSync(tmpfile, filename);\n  } catch (err) {\n    try {\n      fs.unlinkSync(tmpfile);\n    } catch (e) {}\n\n    throw err;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}